# -*- coding: utf-8 -*-
"""Copy of motor_code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cj5u9yDfcxrfEabnjDU9vczML_6zJ-pG
"""

from RpiMotorLib import RpiMotorLib
from RPi.GPIO import RPi.GPIO


dirStp = {"U": [12, 16],
          "T": [18, 32],
          "F": [35, 37],
          "R": [3, 5],
          "B": [7, 11],
          "L": [13, 15]}

# Choose pins for each motor; define GPIO pins
GPIO_pins = (-1, -1, -1)    ## Microstep Resolution MS1-MS3 -> GPIO Pin

# Instance of each motor (6)
motor1_U = RpiMotorLib.A4988Nema(dirStp["U"][0], dirStp["U"][1], GPIO_pins, "A4988")
motor2_L = RpiMotorLib.A4988Nema(dirStp["T"][0], dirStp["T"][1], GPIO_pins, "A4988")
motor3_F = RpiMotorLib.A4988Nema(dirStp["F"][0], dirStp["F"][1], GPIO_pins, "A4988")
motor4_R = RpiMotorLib.A4988Nema(dirStp["R"][0], dirStp["R"][1], GPIO_pins, "A4988")
motor5_B = RpiMotorLib.A4988Nema(dirStp["B"][0], dirStp["B"][1], GPIO_pins, "A4988")
motor6_D = RpiMotorLib.A4988Nema(dirStp["D"][0], dirStp["D"][1], GPIO_pins, "A4988")

# check if half is 90 degrees when testing
moves = {
    "U" :motor1_U.motor_go(True, "Half" , 100, .0005, False, .05),              # False --> counter clockwise
    "U\'":motor1_U.motor_go(False, "Half" , 100, .0005, False, .05),
    "U2":motor1_U.motor_go(False, "Full" , 100, .0005, False, .05),
    "L":motor2_L.motor_go(True, "Half" , 100, .0005, False, .05),
    "L\'":motor2_L.motor_go(False, "Half" , 100, .0005, False, .05),
    "L2":motor2_L.motor_go(False, "Full" , 100, .0005, False, .05),
    "F":motor3_F.motor_go(True, "Half" , 100, .0005, False, .05),
    "F\'":motor3_F.motor_go(False, "Half" , 100, .0005, False, .05),
    "F2":motor3_F.motor_go(False, "Full" , 100, .0005, False, .05),
    "R":motor4_R.motor_go(True, "Half" , 100, .0005, False, .05),
    "R\'":motor4_R.motor_go(False, "Half" , 100, .0005, False, .05),
    "R2":motor4_R.motor_go(False, "Full" , 100, .0005, False, .05),
    "B":motor5_B.motor_go(True, "Half" , 100, .0005, False, .05),
    "B\'":motor5_B.motor_go(False, "Half" , 100, .0005, False, .05),
    "B2":motor5_B.motor_go(False, "Full" , 100, .0005, False, .05),
    "D":motor6_D.motor_go(True, "Half" , 100, .0005, False, .05),
    "D\'":motor6_D.motor_go(False, "Half" , 100, .0005, False, .05),
    "D2":motor6_D.motor_go(False, "Full" , 100, .0005, False, .05),

    }
solution = ["D2", "R\'" ,"D\'", "F2", "B", "D", "R2", "D2", "R'", "F2", "D\'", "F2", "U'" ,"B2","L2", "U2","D", "R2", "U"] #solution given by raspberry pi
for move in solution:
  moves.get(move)

# motor_stop()

  solution = "D2, R\' ,D\', F2, B, D, R2, D2, R\', F2, D\', F2, U\' ,B2,L2, U2,D, R2, U" # try this
solution = "D2", "R\'" ,"D\'", "F2", "B", "D", "R2", "D2", "R'", "F2", "D\'", "F2", "U'" ,"B2","L2", "U2","D", "R2", "U"# or this if it doesn't work

# #Other way
# solution = "D2", "R'" ,"D'", "F2", "B", "D", "R2", "D2", "R'", "F2", "D'", "F2", "U'" ,"B2","L2", "U2","D", "R2", "U"
# for move in solution:
#   if move == "R":
#     motor4_R.motor_go(False, "Half" , 100, .001, False, .05) #too long, have to do that for every single letter
#   elif move =="B":